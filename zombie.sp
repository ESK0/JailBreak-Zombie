/* Plugin Template generated by Pawn Studio */
/*////////////////////////////////////////////
//////////			NAPADY			//////////
//////////////////////////////////////////////

///////////////////////////////////////////// */

#include <sourcemod>
#include <cstrike>
#include <colors>
#include <sdktools>
#include <sdkhooks>
#define TAG "[{darkred}DenZet{default}]"
#define VER "1.0a"

///////////////////////////
new UserMsg:g_FadeUserMsgId;
// OFFSETY //
new g_Offset_Health = -1;
new g_Offset_Ammo = -1;
// SKYBOX //
new	Handle:g_CvarSky = INVALID_HANDLE;
// CLASSY //
static Pyro[32];
static Tank[32];
static Rychlik[32];
static Skokan[32];
// CLASS TIMERS //
new Handle: PyromanMolotovTimer[32] = INVALID_HANDLE;
// TOGGLERS //
new z_Enable = 0;
// TIMERS //
new Handle:g_EnableTimer = INVALID_HANDLE;
new Handle:GiveAmmoTimer[32] = INVALID_HANDLE;
new Handle:CheckPlayerWeaponTimer[32] = INVALID_HANDLE;
// JUST SHITS //
new String:SkyString[64];
new PocetZijicichCT = 0;
// ENMUS //
enum Slots
{
	Slot_Primary,
	Slot_Secondary,
	Slot_Knife,
	Slot_Grenade,
	Slot_C4,
	Slot_None
};
/* //////////////////////////////////////////////////////
   //////////			THE HELL IS BELOW		/////////
   ////////////////////////////////////////////////////// */
public Plugin:myinfo = 
{
	name = "JB ZOMBIE DAY",
	author = "ESK0 & NEREZIEL",
	description = "NewEra Zombie day",
	version = "1.0",
	url = "www.newera-portal.eu"
}
public OnPluginStart()
{
	HookEvent("round_end", RoundEnd);
	HookEvent("round_start", RoundStart);
	HookEvent("player_spawn", PlayerSpawn);
	HookEvent("weapon_fire", WeaponFire);
	RegAdminCmd("sm_denz", Command_zombie, ADMFLAG_SLAY);
	RegAdminCmd("sm_denzoff", Command_zombieoff, ADMFLAG_SLAY);
	g_FadeUserMsgId = GetUserMessageId("Fade");
	
	g_Offset_Health = FindSendPropOffs("CBasePlayer", "m_iHealth");
	if (g_Offset_Health == -1)
	{
			SetFailState("Unable to find offset for health.");
	}
	g_Offset_Ammo = FindSendPropOffs("CCSPlayer", "m_iAmmo");
	if(g_Offset_Ammo == -1)
	{
		SetFailState("Unable to find ammo offset.");
	}
}
/* //////////////////////////////////////////////////
   //////////			ON MAP START		/////////
   ////////////////////////////////////////////////// */
public OnMapStart()
{
	g_CvarSky = FindConVar("sv_skyname");
	GetConVarString(g_CvarSky, SkyString, sizeof(SkyString));
	z_Enable = 0; 
}
/* //////////////////////////////////////////////////////////////
   //////////			ROUND END & ROUND START			/////////
   ////////////////////////////////////////////////////////////// */
public Action:RoundEnd(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	z_Enable = 0;
	PocetZijicichCT = 0;
	for(new i = 1; i < MaxClients; i++)
	{
		SDKUnhook(i, SDKHook_OnTakeDamage, OnTakeDamage);
		SDKUnhook(i, SDKHook_WeaponCanUse, OnWeaponDecideUse);
		if(IsValidClient(i))
		{
			SetEntityGravity(i, 1.0);
			PerformBlind(i, 0);
			Pyro[i] = 0;
			Tank[i] = 0;
			Rychlik[i] = 0;
			Skokan[i] = 0;
		}
	}
	if ( g_EnableTimer != INVALID_HANDLE) {KillTimer(g_EnableTimer);}
	else if ( GiveAmmoTimer[client] != INVALID_HANDLE) {KillTimer(GiveAmmoTimer[client]);}
	else if ( CheckPlayerWeaponTimer[client] != INVALID_HANDLE) {KillTimer(CheckPlayerWeaponTimer[client]);}
	else if ( PyromanMolotovTimer[client] != INVALID_HANDLE) {KillTimer(PyromanMolotovTimer[client]);}	
}
public Action:RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	PocetZijicichCT = 0;
	for(new i = 1; i < MaxClients; i++)
	{
		SDKUnhook(i, SDKHook_WeaponCanUse, OnWeaponDecideUse);
		if(IsValidClient(i))
		{
			SetEntityMoveType(i, MOVETYPE_WALK);
			SetEntityGravity(i, 1.0);
			Pyro[i] = 0;
			Tank[i] = 0;
			Rychlik[i] = 0;
			Skokan[i] = 0;
		}
	}
	if ( g_EnableTimer != INVALID_HANDLE) {KillTimer(g_EnableTimer);}
	else if ( GiveAmmoTimer[client] != INVALID_HANDLE) {KillTimer(GiveAmmoTimer[client]);}
	else if ( PyromanMolotovTimer[client] != INVALID_HANDLE) {KillTimer(PyromanMolotovTimer[client]);}	
	g_EnableTimer = CreateTimer(60.0, BlockZombieDay);
	decl String:buffer[512];
	Format(buffer, sizeof(buffer), "%s", SkyString);
	SetCvar("sv_skyname", buffer);
	z_Enable = 0;
}
public Action:PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	SDKUnhook(client, SDKHook_WeaponCanUse, OnWeaponDecideUse);
}
/* //////////////////////////////////////////////////
   //////////			DISALLOW ZOMBIE		/////////
   ////////////////////////////////////////////////// */
public Action:BlockZombieDay(Handle:timer, any:client)
{
	z_Enable = 1;
}
/* //////////////////////////////////////////////////////
   //////////			ZOMBIE DAY BELOW		/////////
   ////////////////////////////////////////////////////// */
public Action:Command_zombieoff(client, args)
{
	if( z_Enable == 1)
	{
		for(new i = 1; i <= MaxClients; i++)
		{
			if(IsValidClient(i))
			{
			ForcePlayerSuicide(i);
			}
		}
		z_Enable = 0;
	}
}
public Action:Command_zombie(client, args)
{
	if( z_Enable == 0)
	{
		PrintCenterTextAll("Vezni byli infikovani\n BY ESK0");
		CPrintToChatAll("%s {olive} Vezni byli infikováni.", TAG);
		CPrintToChatAll("%s {olive} By ESK0 ver: %s", TAG, VER);
		// TIMER //
		CreateTimer(15.0, RemoveFreeze);
		// MENU //
		new Handle:ZombieSelectMenu = CreateMenu(ZombieSelected);
		SetMenuTitle(ZombieSelectMenu, "Zvol si zombika");
		AddMenuItem(ZombieSelectMenu, "_","-", ITEMDRAW_SPACER);
		AddMenuItem(ZombieSelectMenu, "pyro", "Pyroman\n700 HP + 75HP za kazde zijici CT a moznost hazet molotovy.");
		AddMenuItem(ZombieSelectMenu, "skokan", "Skokan\n400 HP + 50HP za kazde zijici CT. Mala gravitace.");
		AddMenuItem(ZombieSelectMenu, "tank", "Tank\n1000 HP + 200HP za kazde zijici CT, Mala gravitace a pomalejsi chuze");
		AddMenuItem(ZombieSelectMenu, "rychlik", "Rychlik\n200 HP + 50HP za kazde zijici CT, Mala gravitace a rychlejsi chuze");
		// NASTAVENI SKYBOXU //
		SetCvar("sv_skyname", "embassy");
		// LOOP //
		for(new i = 1; i <= MaxClients; i++)
		{
			if (IsValidClient(i))
			{
				if (GetClientTeam(i) == CS_TEAM_T)
				{
					CheckPlayerWeaponTimer[i] = CreateTimer(1.0, CheckPlayerWeapon, i,TIMER_REPEAT);
					SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
					SetEntityGravity(i, 1.0);
					SetEntProp(i, Prop_Data, "m_takedamage", 0, 1);
					SetEntProp(i, Prop_Send, "m_bHasHelmet", 0);
					decl String: name[MAX_NAME_LENGTH];
					GetClientName(i, name, sizeof(name));
					CPrintToChat(i, "%s {olive}Byl jsi infikovan virem, který tě znehybnl na 15 sekund!", TAG);
					SetEntityMoveType(i, MOVETYPE_NONE);
					DisplayMenu(ZombieSelectMenu, i, MENU_TIME_FOREVER);
				}
				else if (IsValidClient(i) && GetClientTeam(i) == CS_TEAM_CT)
				{
					SDKHook(i, SDKHook_OnTakeDamage, OnTakeDamage);
					PocetZijicichCT++;
					GiveAmmoTimer[i] = CreateTimer(30.0, GiveAmmo, i,TIMER_REPEAT);
				}
				PerformBlind(i, 163);
			}	
		}
		z_Enable = 1;
	}
	else if(z_Enable == 1)
	{
		CPrintToChat(client, "%s {olive} Zombie Apokalypsa právě probíhá, nebo není k dispozici.", TAG);
	}
}
public Action:OnTakeDamage(victim, &attacker, &inflictor, &Float:damage, &damagetype)
{
	if ( attacker == victim && damagetype == DMG_BURN && Pyro[attacker] == 1)
	{
		return Plugin_Handled;
	}
	else if ( attacker != victim && damagetype == DMG_BURN && Pyro[victim] == 1)
	{
		return Plugin_Handled;
	}
	
	return Plugin_Continue;
}
/* //////////////////////////////////////////////
   //////////			WEAPON FIRE		/////////
   ////////////////////////////////////////////// */
public WeaponFire(Handle:event, const String:name[],bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	new String: wepname[64];
	GetEventString(event, "weapon", wepname, sizeof(wepname));
	
	if (IsValidClient(client))
	{
		if(Pyro[client] >= 1 && (StrEqual(wepname, "molotov", false)))
		{
			PyromanMolotovTimer[client] = CreateTimer(15.0, PyromanMoloto, client);
		}
	}
}
/* //////////////////////////////////////////////////////////
   //////////			DISALLOW WEAPON PICK UP		/////////
   ////////////////////////////////////////////////////////// */
public Action:OnWeaponDecideUse(client, weapon)
{ 
	if(client > 0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client) == CS_TEAM_T && Pyro[client] > 1)
	{
		decl String:sClassname[128];
		GetEntityClassname(weapon, sClassname, sizeof(sClassname));
		if(StrContains(sClassname, "molotov", false) == -1)
		{
			return Plugin_Handled;
		}
	}
	else if(client > 0 && IsClientInGame(client) && IsPlayerAlive(client) && GetClientTeam(client) == CS_TEAM_T)
	{
		decl String:sClassname[128];
		GetEntityClassname(weapon, sClassname, sizeof(sClassname));
		if(StrContains(sClassname, "knife", false) == -1)
		{ 
			return Plugin_Handled;
		}
	}
	return Plugin_Continue;
}
/* //////////////////////////////////////////////////
   //////////			REMOVE FREEZE		/////////
   ////////////////////////////////////////////////// */
public Action:RemoveFreeze(Handle:timer, any:client)
{
	if (z_Enable == 1)
	{
		for(new i = 1; i < MaxClients; i++)
		{
			if(IsValidClient(i) && GetClientTeam(i) == CS_TEAM_T)
			{
				SetEntityMoveType(i, MOVETYPE_WALK);
				CPrintToChat(i, "%s {olive} Nyní se můžeš volně pohybovat.", TAG);
				SetEntProp(i, Prop_Data, "m_takedamage", 2, 1);
			}
		}
	}
}
/* //////////////////////////////////////////////////////////
   //////////			CHECK PLAYER'S WEAPONS		/////////
   ////////////////////////////////////////////////////////// */
public Action:CheckPlayerWeapon(Handle:timer, any: client)
{
	if (z_Enable == 1)
	{
		for(new i = 1; i < MaxClients; i++)
		{
			if (IsValidClient(i) && GetClientTeam(i) == CS_TEAM_T)
			{
				RemoveWeaponBySlot(i, Slot_Primary);
				RemoveWeaponBySlot(i, Slot_Secondary);
				RemoveWeaponBySlot(i, Slot_C4);
				RemoveWeaponBySlot(i, Slot_Grenade);
			}
		}
	}
}

/* //////////////////////////////////////////////////
   //////////			UNLIMITED AMMO		/////////
   ////////////////////////////////////////////////// */
public Action:GiveAmmo(Handle:timer)
{
	for(new i = 1; i < MaxClients; i++)
	{
		if(IsValidClient(i) && GetClientTeam(i) == CS_TEAM_CT && z_Enable == 1)
		{
			new WepEntity;
			for(new wep; wep < 4; wep++)
			{
				if((WepEntity = GetPlayerWeaponSlot(i, wep)) != -1)
				{
					new iPrimeMagOffset = GetEntProp(WepEntity, Prop_Send, "m_iPrimaryAmmoType");
					if(iPrimeMagOffset > 0)
					{
						SetEntData(i, g_Offset_Ammo + (4 * iPrimeMagOffset), 1000, _, true)
					}
				}
			}
			return Plugin_Handled;
		}
		else
		{
			return Plugin_Handled;
		}
	}
	return Plugin_Continue;
}
/* //////////////////////////////////////////////////////
   //////////			WHEN U PICK ZOMBIE		/////////
   ////////////////////////////////////////////////////// */  
public ZombieSelected(Handle:ZombieSelectMenu, MenuAction:action, client, Position)
{
	if(action == MenuAction_Select)
	{
		new ClientKnife = GetPlayerWeaponSlot(client, 2);
		decl String:Item[20];
		GetMenuItem(ZombieSelectMenu, Position, Item, sizeof(Item));
		
		if(StrEqual(Item, "pyro"))
		{
			SDKHook(client, SDKHook_WeaponCanUse, OnWeaponDecideUse);
			Pyro[client]++;
			CPrintToChat(client, "%s {olive}Vybral sis pyromana", TAG)
			SetEntData(client, g_Offset_Health, PocetZijicichCT*75+700);
			new Knife;
			if(IsValidEntity(ClientKnife) && ClientKnife != INVALID_ENT_REFERENCE) 
			{
				RemovePlayerItem(client, ClientKnife), RemoveEdict(ClientKnife), Knife = GivePlayerItem(client, "weapon_knife_butterfly");
			}
			GivePlayerItem(client, "weapon_molotov");
			EquipPlayerWeapon(client, Knife);
		}
		else if(StrEqual(Item, "skokan"))
		{
			CPrintToChat(client, "%s {olive}Vybral sis skokana", TAG)
			SetEntData(client, g_Offset_Health, PocetZijicichCT*50+400);
			SetEntPropFloat(client, Prop_Data, "m_flLaggedMovementValue", 1.1);
			SetEntityGravity(client, 0.65);
			Skokan[client]++;
		}
		else if(StrEqual(Item, "tank"))
		{
			CPrintToChat(client, "%s {olive}Vybral sis tanka", TAG)
			SetEntData(client, g_Offset_Health, PocetZijicichCT*200+1000);
			SetEntPropFloat(client, Prop_Data, "m_flLaggedMovementValue", 0.86);
			SetEntityGravity(client, 0.85);
			Tank[client]++;
		}
		else if(StrEqual(Item, "rychlik"))
		{
			CPrintToChat(client, "%s {olive}Vybral sis rychlíka", TAG)
			SetEntData(client, g_Offset_Health, PocetZijicichCT*50+200);
			SetEntPropFloat(client, Prop_Data, "m_flLaggedMovementValue", 1.35);
			SetEntityGravity(client, 0.65);
			Rychlik[client]++;
		}
	}
}
/* //////////////////////////////////////////////////
   //////////			CLASS POWERS		/////////
   ////////////////////////////////////////////////// */
public Action: PyromanMoloto(Handle: timer, any: client)
{
	RemoveWeaponBySlot(client, Slot_Grenade);
	GivePlayerItem(client, "weapon_molotov");
} 
   
/* //////////////////////////////////////////////
   //////////			DARKNESS		/////////
   ////////////////////////////////////////////// */
PerformBlind(client, amount)
{
	new targets[2];
	targets[0] = client;
	
	new duration = 1536;
	new holdtime = 1536;
	
	new flags;
	if (amount == 0)
	{
		flags = (0x0001 | 0x0010);
	}
	else
	{
		flags = (0x0002 | 0x0008);
	}
	
	new color[4] = { 0,0,0,0 };
	color[3] = amount;
	new Handle:message = StartMessageEx(g_FadeUserMsgId, targets, 1);
	if (GetUserMessageType() == UM_Protobuf)
	{
		PbSetInt(message, "duration", duration);
		PbSetInt(message, "hold_time", holdtime);
		PbSetInt(message, "flags", flags);
		PbSetColor(message, "clr", color);
	}
	else
	{
		BfWriteShort(message, duration);
		BfWriteShort(message, holdtime);
		BfWriteShort(message, flags);		
		BfWriteByte(message, color[0]);
		BfWriteByte(message, color[1]);
		BfWriteByte(message, color[2]);
		BfWriteByte(message, color[3]);
	}
	EndMessage();
}
/* //////////////////////////////////////////
   //////////			STOCKS		/////////
   ////////////////////////////////////////// */ 
stock SetCvar(String:scvar[], String:svalue[])
{
	new Handle:cvar = FindConVar(scvar);
	SetConVarString(cvar, svalue, true);
}
stock bool:IsValidClient(client, bool:alive = false)
{
    if(client >= 1 && client <= MaxClients && IsClientConnected(client) && IsClientInGame(client) && (alive == false || IsPlayerAlive(client)))
    {
        return true;
    }
   
    return false;
}
stock bool:RemoveWeaponBySlot(client_index, Slots:slot)
{
	new entity_index = GetPlayerWeaponSlot(client_index, _:slot);
	if (entity_index>0)
	{
		RemovePlayerItem(client_index, entity_index);
		AcceptEntityInput(entity_index, "Kill");
		return true;
	}
	return false;
}